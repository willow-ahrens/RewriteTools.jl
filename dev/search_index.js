var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = RewriteTools","category":"page"},{"location":"#RewriteTools","page":"Home","title":"RewriteTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RewriteTools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RewriteTools]","category":"page"},{"location":"#RewriteTools.Term","page":"Home","title":"RewriteTools.Term","text":"Term(f, args::AbstractArray)\n\nSymbolic expression representing the result of calling f(args...).\n\noperation(t::Term) returns f\narguments(t::Term) returns args\n\n\n\n\n\n","category":"type"},{"location":"#RewriteTools.flatten_term-Tuple{Any, Any}","page":"Home","title":"RewriteTools.flatten_term","text":"flatten_term(⋆, x)\n\nReturn a flattened expression with the numbers at the back.\n\nExample\n\njulia> ex = RewriteTools.flatten_term(+, term(+, :a, term(+, :b, :c)))\na + b + c\n\njulia> ex == term(+, :a, :b, :c)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#RewriteTools.rewrite_rhs-Tuple{Expr}","page":"Home","title":"RewriteTools.rewrite_rhs","text":"rewrite_rhs(expr::Expr)\n\nRewrite the expr by dealing with :where if necessary. The :where is rewritten from, for example, ~x where f(~x) to f(~x) ? ~x : nothing.\n\n\n\n\n\n","category":"method"},{"location":"#RewriteTools.@capture-Tuple","page":"Home","title":"RewriteTools.@capture","text":"@capture [SLOTS...] ex pattern\n\nUses a Rule object to capture an expression if it matches the pattern. Returns true and injects slot variable match results into the calling scope when the pattern matches, otherwise returns false. The rule language for specifying the pattern is the same in @capture as it is in @rule.\n\njulia> @syms a; ex = a^a;\n\njulia> if @capture ex (~x)^(~x)\n           @show x\n       elseif @capture ex 2(~y)\n           @show y\n       end;\nx = a\n\nSee also: @rule, @slots\n\n\n\n\n\n","category":"macro"},{"location":"#RewriteTools.@rule-Tuple","page":"Home","title":"RewriteTools.@rule","text":"@rule [SLOTS...] LHS => RHS\n\nCreates a Rule object. A rule object is callable, and takes an expression and rewrites it if it matches the LHS pattern to the RHS expression, returns nothing otherwise. The rule language is described below.\n\nLHS can be any possibly nested function call expression where any of the arguments can optionally be a Slot (~x) or a Segment (~x...) (described below).\n\nSLOTS is an optional list of symbols to be interpted as slots or segments directly (without using ~).  To declare slots for several rules at once, see the @slots macro.\n\nIf an expression matches LHS entirely, then it is rewritten to the result of the expression RHS, whose local scope includes the slot matches as variables.\n\nSlot:\n\nA Slot variable is written as ~x and matches a single expression. x is the name of the variable. If a slot appears more than once in an LHS expression then expression matched at every such location must be equal (as shown by isequal).\n\nExample:\n\nSimple rule to turn any sin into cos:\n\njulia> @syms a b c\n(a, b, c)\n\njulia> r = @rule sin(~x) => cos(x)\nsin(~x) => cos(x)\n\njulia> r(sin(1+a))\ncos((1 + a))\n\nA rule with 2 segment variables\n\njulia> r = @rule sin(~x + ~y) => sin(x)*cos(y) + cos(x)*sin(y)\nsin(~x + ~y) => sin(x) * cos(y) + cos(x) * sin(y)\n\njulia> r(sin(a + b))\ncos(a)*sin(b) + sin(a)*cos(b)\n\nA rule that matches two of the same expressions:\n\njulia> r = @rule sin(~x)^2 + cos(~x)^2 => 1\nsin(~x) ^ 2 + cos(~x) ^ 2 => 1\n\njulia> r(sin(2a)^2 + cos(2a)^2)\n1\n\njulia> r(sin(2a)^2 + cos(a)^2)\n# nothing\n\nA rule without ~\n\njulia> r = @slots x y z @rule x(y + z) => xy + xz\nx(y + z) => xy + xz\n\nSegment:\n\nA Segment variable matches zero or more expressions in the function call. Segments may be written by splatting slot variables (~x...).\n\nExample:\n\nThis implements the distributive property of multiplication: +(~ys...) matches expressions like a + b, a+b+c and so on. On the RHS ys presents as any old julia array.\n\njulia> r = @rule ~x * +((~ys...)) => sum(map(y-> x * y, ys));\n\njulia> r(2 * (a+b+c))\n((2 * a) + (2 * b) + (2 * c))\n\nA segment without ~.\n\njulia> r = @slots xs @rule min(xs...) => foldl(min, xs, Inf);\n\njulia> r(min(a, b, c))\nmin(min(a, b), c)\n\n**Predicates**:\n\nThere are two kinds of predicates, namely over slot variables and over the whole rule.\nFor the former, predicates can be used on both `~x` and `~x...` like `~x::f` or `~x::f...`.\nHere `f` can be any julia function. In the case of a slot the function gets a single\nmatched subexpression, in the case of segment, it gets an array of matched expressions.\n\nThe predicate should return `true` if the current match is acceptable, and `false`\notherwise.\n\n\njulia julia> twoπs(x::Number) = abs(round(x/(2π)) - x/(2π)) < 10^-9 twoπs (generic function with 1 method)\n\njulia> twoπs(x) = false twoπs (generic function with 2 methods)\n\njulia> r = @slots x y z @rule sin(+(x..., y::twoπs, z...)) => sin(+(x..., z...)) sin(+(x..., y::twoπs, z...)) => sin(+(x..., z...))\n\njulia> r(sin(a+3π))\n\njulia> r(sin(a+6π)) sin(a)\n\njulia> r(sin(a+6π+c)) sin((a + c))\n\n\nFor the predicate over the whole rule, use `@rule <LHS> => <RHS> where <predicate>`:\n\n\njulia> @syms a b;\n\njulia> predicate(x) = x === a;\n\njulia> r = @rule ~x => x where f(x);\n\njulia> r(a) a\n\njulia> r(b) === nothing true ```\n\nNote that this is syntactic sugar and that it is the same as something like @rule ~x => f(x) ? x : nothing.\n\nCompatibility: Segment variables may still be written as (~~x), and slot (~x) and segment (~x... or ~~x) syntaxes on the RHS will still substitute the result of the matches.\n\nSee also: @capture, @slots\n\n\n\n\n\n","category":"macro"},{"location":"#RewriteTools.@slots-Tuple","page":"Home","title":"RewriteTools.@slots","text":"@slots [SLOTS...] ex\n\nDeclare SLOTS as slot variables for all @rule or @capture invocations in the expression ex.\n\nExample:\n\njulia> @slots x y z a b c Chain([\n    (@rule x^2 + 2x*y + y^2 => (x + y)^2),\n    (@rule x^a * y^b => (x*y)^a * y^(b-a)),\n    (@rule +(x...) => sum(x)),\n])\nChain(Rule{Term[...]))\n\nSee also: @rule, @capture\n\n\n\n\n\n","category":"macro"}]
}
