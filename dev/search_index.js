var documenterSearchIndex = {"docs":
[{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"CurrentModule = RewriteTools.Rewriters","category":"page"},{"location":"rewriters/#Composing-Rewriters","page":"Rewriters","title":"Composing Rewriters","text":"","category":"section"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"Rewriters are powerful tools for transforming expressions. They can be composed and chained together to create sophisticated transformations.","category":"page"},{"location":"rewriters/#Overview-of-Composing-Rewriters","page":"Rewriters","title":"Overview of Composing Rewriters","text":"","category":"section"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"A rewriter is any callable object that takes an expression and returns either a new expression or nothing. Nothing indicates no applicable changes. The RewriteTools.Rewriters module provides several types of rewriters:","category":"page"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"Empty(): Always returns nothing.\nChain(itr): Chains an iterator of rewriters into a single rewriter. Each rewriter is applied in sequence.\nRestartedChain(itr): Similar to Chain(itr) but restarts from the first rewriter after a successful application.\nIfElse(cond, rw1, rw2): Applies rw1 if cond returns true, otherwise rw2.\nIf(cond, rw): Equivalent to IfElse(cond, rw, Empty()).\nPrewalk(rw): Performs a pre-order traversal of an expression, applying rw at each step.\nPostwalk(rw): Post-order traversal, applying rw.\nFixpoint(rw): Repeatedly applies rw until no further changes occur.\nPrestep(rw): Recursively rewrites each node using rw. Only recurses if rw is not nothing.\nRewrite(rw): If rw(x) returns nothing, Rewrite returns x instead.","category":"page"},{"location":"rewriters/#Chaining-Rewriters","page":"Rewriters","title":"Chaining Rewriters","text":"","category":"section"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"Rewriters can be combined into a chain, allowing multiple rules to be applied sequentially:","category":"page"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"julia> using RewriteTools\n\njulia> using RewriteTools.Rewriters\n\njulia> powexpand = @rule :call(:^, ~x, ~n) => :($x * $x^$(n - 1))\n(:call)(:^, ~x, ~n) => Core._expr(:call, :*, x, Core._expr(:call, :^, x, n - 1))\n\njulia> powid = @rule :call(:^, ~x, 1) => :($x)\n(:call)(:^, ~x, 1) => x\n\njulia> cas = Chain([powexpand, powid])\nChain{Vector{RewriteTools.Rule{RewriteTools.Term}}}(RewriteTools.Rule{RewriteTools.Term}[(:call)(:^, ~x, ~n) => Core._expr(:call, :*, x, Core._expr(:call, :^, x, n - 1)), (:call)(:^, ~x, 1) => x])\n\njulia> cas(:((sin(x) + cos(x))^2))\n:((sin(x) + cos(x)) * (sin(x) + cos(x)) ^ 1)","category":"page"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"An important feature of Chain is that it returns nothing if there are no changes:","category":"page"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"julia> Chain([powid, powexpand])(:(x + y))\n","category":"page"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"Postwalk allows us to further rewrite subterms of our expressions.","category":"page"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"julia> cas2 = Postwalk(Chain([powid, powexpand]))\nPostwalk{Chain{Vector{RewriteTools.Rule{RewriteTools.Term}}}}(Chain{Vector{RewriteTools.Rule{RewriteTools.Term}}}(RewriteTools.Rule{RewriteTools.Term}[(:call)(:^, ~x, 1) => x, (:call)(:^, ~x, ~n) => Core._expr(:call, :*, x, Core._expr(:call, :^, x, n - 1))]))\n\njulia> cas2(:((sin(x) + cos(x)) * (sin(x) + cos(x)) ^ 1))\n:((sin(x) + cos(x)) * (sin(x) + cos(x)))","category":"page"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"Fixpoint allows us to rewrite until no changes can be made","category":"page"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"julia> cas3 = Fixpoint(Postwalk(Chain([powid, powexpand])))\nFixpoint{Postwalk{Chain{Vector{RewriteTools.Rule{RewriteTools.Term}}}}}(Postwalk{Chain{Vector{RewriteTools.Rule{RewriteTools.Term}}}}(Chain{Vector{RewriteTools.Rule{RewriteTools.Term}}}(RewriteTools.Rule{RewriteTools.Term}[(:call)(:^, ~x, 1) => x, (:call)(:^, ~x, ~n) => Core._expr(:call, :*, x, Core._expr(:call, :^, x, n - 1))])))\n\njulia> cas3(:((sin(x) + cos(x))^4))\n:((sin(x) + cos(x)) * ((sin(x) + cos(x)) * ((sin(x) + cos(x)) * (sin(x) + cos(x)))))","category":"page"},{"location":"rewriters/","page":"Rewriters","title":"Rewriters","text":"IfElse{F, A, B}\nRewrite\nNoRewrite\nFixpoint{C}\nPrewalk{C}\nPostwalk{C}\nChain{C}\nPrestep{C}","category":"page"},{"location":"rewriters/#RewriteTools.Rewriters.IfElse","page":"Rewriters","title":"RewriteTools.Rewriters.IfElse","text":"`IfElse(cond, rw1, rw2)`\n\nReturns a function which runs the `cond` function on the input, applies\n`rw1` if cond returns true, `rw2` if it retuns false. For example, one\n    might set `rw2` to `NoRewrite()` or `NoSaturate()`\n\n\n\n\n\n","category":"type"},{"location":"rewriters/#RewriteTools.Rewriters.Rewrite","page":"Rewriters","title":"RewriteTools.Rewriters.Rewrite","text":"Rewrite(rw)\n\nA rewriter which returns the original argument even if `rw` returns nothing\n\n\n\n\n\n","category":"type"},{"location":"rewriters/#RewriteTools.Rewriters.NoRewrite","page":"Rewriters","title":"RewriteTools.Rewriters.NoRewrite","text":"NoRewrite()\n\nA rewriter which always returns `nothing`\n\n\n\n\n\n","category":"type"},{"location":"rewriters/#RewriteTools.Rewriters.Fixpoint","page":"Rewriters","title":"RewriteTools.Rewriters.Fixpoint","text":"`Fixpoint(rw)`\n\nAn rewriter which repeatedly applies `rw` to `x` until no changes are made. If\nthe rewriter first returns `nothing`, returns `nothing`.\n\n\n\n\n\n","category":"type"},{"location":"rewriters/#RewriteTools.Rewriters.Prewalk","page":"Rewriters","title":"RewriteTools.Rewriters.Prewalk","text":"`Prewalk(rw)`\n\nAn rewriter which recursively rewrites each node using `rw`, then rewrites\nthe arguments of the resulting node. If all rewriters return `nothing`,\nreturns `nothing`.\n\n\n\n\n\n","category":"type"},{"location":"rewriters/#RewriteTools.Rewriters.Postwalk","page":"Rewriters","title":"RewriteTools.Rewriters.Postwalk","text":"`Postwalk(rw)`\n\nAn rewriter which recursively rewrites the arguments of each node using\n`rw`, then rewrites the resulting node. If all rewriters return `nothing`,\nreturns `nothing`.\n\n\n\n\n\n","category":"type"},{"location":"rewriters/#RewriteTools.Rewriters.Chain","page":"Rewriters","title":"RewriteTools.Rewriters.Chain","text":"`Chain(itr)`\n\nAn rewriter which rewrites using each rewriter in `itr`. If all rewriters\nreturn `nothing`, return `nothing`.\n\n\n\n\n\n","category":"type"},{"location":"rewriters/#RewriteTools.Rewriters.Prestep","page":"Rewriters","title":"RewriteTools.Rewriters.Prestep","text":"`Prestep(rw)`\n\nAn rewriter which recursively rewrites each node using `rw`. If `rw` is\nnothing, it returns `nothing`, otherwise it recurses to the arguments.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RewriteTools","category":"page"},{"location":"#RewriteTools","page":"Home","title":"RewriteTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RewriteTools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"RewriteTools.jl is a utility for term rewriting. RewriteTools.jl is a fork of SymbolicUtils.jl version 1.17, preserving and simplifying only the functionality related to term rewriting. The semantics of matcher and rewriter objects is simplified and more uniform.  RewriteTools.jl is intended for use with custom ASTs that have syntax which implements SyntaxInterface.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"RewriteTools\")","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"CurrentModule = RewriteTools","category":"page"},{"location":"matchers/#Rule-based-rewriting","page":"Matchers","title":"Rule-based rewriting","text":"","category":"section"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"Rewrite rules match and transform an expression. A rule is written using the @rule macro and creates a callable Rule object.","category":"page"},{"location":"matchers/#Basics-of-Rule-based-Term-Rewriting-in-RewriteTools","page":"Matchers","title":"Basics of Rule-based Term Rewriting in RewriteTools","text":"","category":"section"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"Here is a simple rewrite rule, that uses the formula for the double angle of the sine function:","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"julia> using RewriteTools\n\njulia> r1 = @rule :call(:sin, :call(:*, 2, ~x)) => :(2 * sin($x) * cos($x))\n(:call)(:sin, (:call)(:*, 2, ~x)) => Core._expr(:call, :*, 2, Core._expr(:call, :sin, x), Core._expr(:call, :cos, x))\n\njulia> r1(:(sin(2 * z)))\n:(2 * sin(z) * cos(z))\n","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"The @rule macro pairs a matcher pattern with its consequent (@rule matcher => consequent). When an expression matches the matcher, it's rewritten to the consequent pattern. This rule signifies: if an expression fits the sin(2x) pattern, it's transformed to 2sin(x)cos(x).","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"Applying the rule to a non-matching expression results in nothing, indicating a mismatch:","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"julia> r1(:(sin(3 * z))) === nothing\ntrue","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"Slot variables can match complex expressions:","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"julia> r1(:(sin(2 * (w - z))))\n:(2 * sin(w - z) * cos(w - z))\n","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"But they must represent a single, unified expression:","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"julia> r1(:(sin(2 * (w + z) * (α + β)))) === nothing\ntrue","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"Rules can incorporate multiple slot variables:","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"julia> r2 = @rule :call(:sin, :call(:+, ~x, ~y)) => :(sin($x) * cos($y) + cos($x) * sin($y))\n(:call)(:sin, (:call)(:+, ~x, ~y)) => Core._expr(:call, :+, Core._expr(:call, :*, Core._expr(:call, :sin, x), Core._expr(:call, :cos, y)), Core._expr(:call, :*, Core._expr(:call, :cos, x), Core._expr(:call, :sin, y)))\n\njulia> r2(:(sin(α + β)))\n:(sin(α) * cos(β) + cos(α) * sin(β))\n","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"For matching a variable number of subexpressions, segment variables like ~~xs are used:","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"julia> r3 = @rule :call(:+, ~~xs) => :(sum($xs))\n(:call)(:+, ~(~xs)) => Core._expr(:call, :sum, xs)\n\njulia> r3(:(x + y + z))\n:(sum(Any[:x, :y, :z]))\n","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"Segment variables match vectors of subexpressions, useful for constructing complex transformations:","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"julia> r4 = @rule :call(:*, ~x, :call(:+, ~~ys)) => :(+($(map(y -> :($x * $y), ys)...)))\n(:call)(:*, ~x, (:call)(:+, ~(~ys))) => Core._expr(:call, :+, map((y->begin\n                    #= none:1 =#\n                    Core._expr(:call, :*, x, y)\n                end), ys)...)\n\njulia> r4(:(2 * +(w, w, α, β)))\n:(2w + 2w + 2α + 2β)\n","category":"page"},{"location":"matchers/#Predicates-for-Matching","page":"Matchers","title":"Predicates for Matching","text":"","category":"section"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"Matcher patterns may include slot variables with predicates (~x::f), where f is a function that evaluates the matched expression. Similarly, ~~x::g attaches a predicate g to a segment variable.","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"Example with predicates:","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"julia> r5 = @rule :call(:+, ~x, ~~y::(ys -> iseven(length(ys)))) => \"odd number of terms\"\n(:call)(:+, ~x, ~(~(y::(ys->begin\n                            #= none:1 =#\n                            iseven(length(ys))\n                        end)))) => \"odd number of terms\"\n\njulia> @show r5(:(a + b + c + d))\nr5($(Expr(:quote, :(a + b + c + d)))) = nothing\n\njulia> @show r5(:(b + c + d))\nr5($(Expr(:quote, :(b + c + d)))) = \"odd number of terms\"\n\"odd number of terms\"\n\njulia> @show r5(:(b + c + b))\nr5($(Expr(:quote, :(b + c + b)))) = \"odd number of terms\"\n\"odd number of terms\"\n\njulia> @show r5(:(b + c))\nr5($(Expr(:quote, :(b + c)))) = nothing","category":"page"},{"location":"matchers/#Simplifying-Expressions-with-Rules","page":"Matchers","title":"Simplifying Expressions with Rules","text":"","category":"section"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"To simplify expressions like (sin(x) + cos(x))^2, rules are applied:","category":"page"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"julia> sqexpand = @rule :call(:^, :call(:+, ~x, ~y), 2) => :((($x)^2 + ($y)^2 + 2 * $x * $y))\n(:call)(:^, (:call)(:+, ~x, ~y), 2) => Core._expr(:call, :+, Core._expr(:call, :^, x, 2), Core._expr(:call, :^, y, 2), Core._expr(:call, :*, 2, x, y))\n\njulia> sqexpand(:((sin(x) + cos(x))^2))\n:(sin(x) ^ 2 + cos(x) ^ 2 + 2 * sin(x) * cos(x))\n","category":"page"},{"location":"matchers/#Docs","page":"Matchers","title":"Docs","text":"","category":"section"},{"location":"matchers/","page":"Matchers","title":"Matchers","text":"@rule\n@capture","category":"page"},{"location":"matchers/#RewriteTools.@rule","page":"Matchers","title":"RewriteTools.@rule","text":"@rule LHS => RHS\n\nCreates a Rule object. A rule object is callable, and takes an expression and rewrites it if it matches the LHS pattern to the RHS expression, returns nothing otherwise. The rule language is described below.\n\nLHS can be any possibly nested function call expression where any of the arguments can optionally be a Slot (~x) or a Segment (~x...) (described below).\n\nIf an expression matches LHS entirely, then it is rewritten to the result of the expression RHS, whose local scope includes the slot matches as variables.\n\nSlot:\n\nA Slot variable is written as ~x and matches a single expression. x is the name of the variable. If a slot appears more than once in an LHS expression then expression matched at every such location must be equal (as shown by isequal).\n\nExample:\n\nSimple rule to turn any sin into cos:\n\njulia> @syms a b c\n(a, b, c)\n\njulia> r = @rule sin(~x) => cos(x)\nsin(~x) => cos(x)\n\njulia> r(sin(1+a))\ncos((1 + a))\n\nA rule with 2 segment variables\n\njulia> r = @rule sin(~x + ~y) => sin(x)*cos(y) + cos(x)*sin(y)\nsin(~x + ~y) => sin(x) * cos(y) + cos(x) * sin(y)\n\njulia> r(sin(a + b))\ncos(a)*sin(b) + sin(a)*cos(b)\n\nA rule that matches two of the same expressions:\n\njulia> r = @rule sin(~x)^2 + cos(~x)^2 => 1\nsin(~x) ^ 2 + cos(~x) ^ 2 => 1\n\njulia> r(sin(2a)^2 + cos(2a)^2)\n1\n\njulia> r(sin(2a)^2 + cos(a)^2)\n# nothing\n\nSegment:\n\nA Segment variable matches zero or more expressions in the function call. Segments may be written by splatting slot variables (~x...).\n\nExample:\n\nThis implements the distributive property of multiplication: +(~ys...) matches expressions like a + b, a+b+c and so on. On the RHS ys presents as any old julia array.\n\njulia> r = @rule ~x * +((~ys...)) => sum(map(y-> x * y, ys));\n\njulia> r(2 * (a+b+c))\n((2 * a) + (2 * b) + (2 * c))\n\nPredicates:\n\nThere are two kinds of predicates, namely over slot variables and over the whole rule. For the former, predicates can be used on both ~x and ~x... like ~x::f or ~x::f.... Here f can be any julia function. In the case of a slot the function gets a single matched subexpression, in the case of segment, it gets an array of matched expressions.\n\nThe predicate should return true if the current match is acceptable, and false otherwise.\n\njulia> two_πs(x::Number) = abs(round(x/(2π)) - x/(2π)) < 10^-9\ntwo_πs (generic function with 1 method)\n\njulia> two_πs(x) = false\ntwo_πs (generic function with 2 methods)\n\njulia> r = @rule sin(+(~x..., ~y::two_πs, ~z...)) => sin(+(x..., z...))\nsin(+(x..., y::two_πs, z...)) => sin(+(x..., z...))\n\njulia> r(sin(a+3π))\n\njulia> r(sin(a+6π))\nsin(a)\n\njulia> r(sin(a+6π+c))\nsin((a + c))\n\nFor the predicate over the whole rule, use @rule <LHS> => <RHS> where <predicate>:\n\njulia> @syms a b;\n\njulia> predicate(x) = x === a;\n\njulia> r = @rule ~x => x where f(x);\n\njulia> r(a)\na\n\njulia> r(b) === nothing\ntrue\n\nNote that this is syntactic sugar and that it is the same as something like @rule ~x => f(x) ? x : nothing.\n\nCompatibility: Segment variables may still be written as (~~x), and slot (~x) and segment (~x... or ~~x) syntaxes on the RHS will still substitute the result of the matches.\n\nSee also: @capture\n\n\n\n\n\n","category":"macro"},{"location":"matchers/#RewriteTools.@capture","page":"Matchers","title":"RewriteTools.@capture","text":"@capture ex pattern\n\nUses a Rule object to capture an expression if it matches the pattern. Returns true and injects slot variable match results into the calling scope when the pattern matches, otherwise returns false. The rule language for specifying the pattern is the same in @capture as it is in @rule.\n\njulia> @syms a; ex = a^a;\n\njulia> if @capture ex (~x)^(~x)\n           @show x\n       elseif @capture ex 2(~y)\n           @show y\n       end;\nx = a\n\nSee also: @rule\n\n\n\n\n\n","category":"macro"}]
}
